====
"VARIABLE_DELAY"
====

Subsections

+ `Library`_
+ `Description`_
+ `Dialog Box`_
+ `Default properties`_
+ `Interfacing function`_
+ `Computational function (type 4)`_







Variable delay
--------------



Library
~~~~~~~
Linear


Description
~~~~~~~~~~~
The Variable Transport Delay block can be used to simulate a variable
time delay. The block might be used to model a system with a pipe
where the speed of a motor pumping fluid in the pipe is variable. The
block accepts two inputs: the first input is the signal that passes
through the block; the second input is the time delay.


Dialog Box
~~~~~~~~~~
Set delay parameters Max delay 1 initial input 0 Buffer size 1024

+ Max delay:It defines the largest value the time delay input can
  have.The value cannot be negative.
+ initial input:The output generated by the block until the simulation
  time first exceeds the time delay input.
+ Buffer size: The number of points the block can store.




Default properties
~~~~~~~~~~~~~~~~~~


+ always active: no
+ direct-feedthrough: yes
+ zero-crossing: no
+ mode: no
+ number/sizes of inputs: 2 / -1 1
+ number/sizes of outputs: 1 / -1
+ number/sizes of activation inputs: 0 /
+ number/sizes of activation outputs: 0 /
+ continuous-time state: no
+ discrete-time state: no
+ name of computational function: *variable_delay*



Interfacing function
~~~~~~~~~~~~~~~~~~~~
scilab/macros/scicos_blocks/linear/VARIABLE_DELAY.sci


Computational function (type 4)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


::

    #include "scicos_block.h"
    #include <math.h>
    #include "../machine.h"
    
    #if WIN32
    #define NULL    0
    #endif
    
    extern void sciprint __PARAMS((char *fmt,...));
    
    void variable_delay(scicos_block *block,int flag)
    {/*  rpar[0]=max delay, rpar[1]=init value, ipar[0]=buffer length */
      double* pw,del,t,td;
      int* iw;
      int i,j,k;
      if (flag == 4){/* the workspace is used to store previous values */
        if ((*block->work=
    	 scicos_malloc(sizeof(int)+sizeof(double)* 
    		       block->ipar[0]*(1+block->insz[0])))== NULL ) {
          set_block_error(-16);
          return;
        }
        pw=*block->work; 
        pw[0]=-block->rpar[0]*block->ipar[0];
        for(i=1;i< block->ipar[0];i++){
          pw[i]=pw[i-1]+block->rpar[0];
          for(j=1;j< block->insz[0]+1;j++){
    	pw[i+block->ipar[0]*j]=block->rpar[1];
          }
        }
        iw=(int *) (pw+block->ipar[0]*(1+block->insz[0]));
        *iw=0;
      }else  if (flag == 5){
        scicos_free(*block->work);
      } else if (flag==1) {
        if (get_phase_simulation()==1) do_cold_restart();
        pw=*block->work; 
        iw=(int *) (pw+block->ipar[0]*(1+block->insz[0]));
        t=get_scicos_time();
        del=min(max(0,block->inptr[1][0]),block->rpar[0]);
        td=t-del;
        if(td<pw[*iw]){
          sciprint("delayed time=%f but last stored time=%f \r\n", td, pw[*iw]);
          sciprint("Consider increasing the length of buffer in variable delay block\r\n");
        }
        if (t>pw[(block->ipar[0]+*iw-1)%block->ipar[0]]){
          for(j=1;j< block->insz[0]+1;j++){
    	pw[*iw +block->ipar[0]*j]=block->inptr[0][j-1];
          }
          pw[*iw]=t;
          *iw=(*iw+1)%block->ipar[0];
        }else{
          for(j=1;j< block->insz[0]+1;j++){
    	pw[(block->ipar[0]+*iw-1)%block->ipar[0] +block->ipar[0]*j]=block->inptr[0][j-1];
          }
          pw[(block->ipar[0]+*iw-1)%block->ipar[0]]=t;
        }
    
        i=0;j= block->ipar[0]-1;
    
        while (j-i>1) {
          k=(i+j)/2;
          if (td<pw[(k+*iw)%block->ipar[0]]) {
    	j=k;
          }else if (td>pw[(k+*iw)%block->ipar[0]]) {
    	i=k;
          }else{
    	i=k;
    	j=k;
    	break;
          }
        }
        i=(i+*iw)%block->ipar[0];
        j=(j+*iw)%block->ipar[0];
        del=pw[j]-pw[i];
        if(del!=0.0){
          for (k=1;k<block->insz[0]+1;k++){
    	block->outptr[0][k-1]=((pw[j]-td)*pw[i+block->ipar[0]*k] +
    			       (td-pw[i])*pw[j+block->ipar[0]*k])/del;
          }
        }else{
          for (k=1;k<block->insz[0]+1;k++){
    	block->outptr[0][k-1]=pw[i+block->ipar[0]*k];
          }
        }
      }
    }



Ramine Nikoukhah 2004-06-22
.. _Computational function (type 4): ://./scicos/VARIABLE_DELAY.htm#SECTION005811600000000000000
.. _Description: ://./scicos/VARIABLE_DELAY.htm#SECTION005811200000000000000
.. _Interfacing function: ://./scicos/VARIABLE_DELAY.htm#SECTION005811500000000000000
.. _Dialog Box: ://./scicos/VARIABLE_DELAY.htm#SECTION005811300000000000000
.. _Default properties: ://./scicos/VARIABLE_DELAY.htm#SECTION005811400000000000000
.. _Library: ://./scicos/VARIABLE_DELAY.htm#SECTION005811100000000000000


