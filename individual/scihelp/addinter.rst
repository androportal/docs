


addinter
========

new functions interface dynamic link at run time.



Calling Sequence
~~~~~~~~~~~~~~~~


::

    addinter(files, spname, fcts)




Arguments
~~~~~~~~~

:files a character string or a vector of character string contain
  object files used to define the new Scilab interface routine
  (interface code, user routines or libraries, system libraries).
: :spname a character string. Name of interface routine entry point
: :fcts vector of character strings. The name of new Scilab function
  implemented in the new interface (in `fin` the order ).
:



Description
~~~~~~~~~~~

`addinter` performs dynamic link of a compiled C or Fortran new Scilab
interface routine and define corresponding scilab functions.

You can use the command `link('show')` to get the number of the shared
libraries. And to reload a new version of an interface a call to
`ulink` is necessary to get rid of the old version.

See `link` for more precision on use.

Number of 'addinter' in a scilab session can be limited by the
operating system. On Windows, you cannot load more than 80 dynamic
libraries at the same time.

Number of functions implemented in a interface is limited to 1000.



Examples
~~~~~~~~


::

    if `haveacompiler`_() then
    
    `chdir`_(TMPDIR);
    `mkdir`_('example_addinter');
    `chdir`_('example_addinter');
    
    src = ['#include <math.h>'
    '#include <api_scilab.h>'
    '#include <Scierror.h>'
    '#include <localization.h>'
    ''
    'static double fun2(double x);'
    ''  
    'void fun1(double *x,double *y) '
    '{'
    '  *y=fun2(*x)/(*x); '
    '} '
    ''
    'static double fun2(double x)'
    '{ '
    '  return( sin(x+1));'
    '}'
    ''
    'int sci_fun1(char *fname)' 
    '{'
    '  int iType1 = 0;'
    '  SciErr sciErr;'
    '  int m1 = 0, n1 = 0;'
    '  double *pdVarOne = NULL;'
    '  int *piAddressVarOne = NULL;'
    ''
    '  CheckRhs(1,1);'
    '  CheckLhs(1,1);'
    ''
    '  sciErr = getVarAddressFromPosition(pvApiCtx, 1, &piAddressVarOne);'
    '  if(sciErr.iErr)'
    '  {'
    ' printError(&sciErr, 0);'
    ' return 0;'
    '  }' 
    ''
    '  sciErr = getVarType(pvApiCtx, piAddressVarOne, &iType1);'
    '  if(sciErr.iErr)'
    '  {'
    ' printError(&sciErr, 0);'
    ' return 0;'
    '  }'
    ''
    '  if (iType1 != sci_matrix)'
    '  {'
    '  Scierror(999,_(""%s: Wrong type for input argument #%d: A string expected.\n""), fname, 1);'
    '  return 0;'
    '  }'
    ''
    '  sciErr = getMatrixOfDouble(pvApiCtx, piAddressVarOne, &m1, &n1, &pdVarOne);'
    '  if(sciErr.iErr)'
    '  {'
    ' printError(&sciErr, 0);'
    ' return 0;'
    '  }'
    ''
    '  fun1(pdVarOne, pdVarOne);'
    '  LhsVar(1) = 1;'
    '  return 0;'
    '}'];
    
    `mputl`_(src,TMPDIR + '/example_addinter/example_addinter.c');
    files=['example_addinter.c'];
    `ilib_build`_('addinter',['fun1_in_scilab','sci_fun1'],files,[]);
    `disp`_(`mgetl`_('loader.sce'));
    `exec`_ loader.sce;
    fun1_in_scilab(%pi)
    
    end // if haveacompiler()




Generated loader.sce with addinter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


::

    // This file is released under the 3-clause BSD license. See COPYING-BSD.
    // Generated by builder.sce : Please, do not edit this file
    // ----------------------------------------------------------------------------
    //
    addinter_path = `get_absolute_file_path`_('loader.sce');
    //
    // ulink previous function with same name
    [bOK, ilib] = `c_link`_('addinter');
    if bOK then
      `ulink`_(ilib);
    end
    //
    list_functions = [ 'fun1_in_scilab'];
    //
    // here we call addinter
    addinter(addinter_path + `filesep`_() + 'addinter' + `getdynlibext`_(), 'addinter', list_functions);
    // remove temp. variables on stack
    clear addinter_path;
    clear bOK;
    clear ilib;
    clear list_functions;
    // ----------------------------------------------------------------------------




See Also
~~~~~~~~


+ `link`_ dynamic linker
+ `intersci`_ Scilab tool to interface C or Fortran functions with
  scilab. Deprecated: Please use SWIG
+ `newfun`_ add a name in the table of functions
+ `clearfun`_ removes primitive
+ `api_scilab`_ api_scilab is the Scilab interface to read/write data
  from/to Scilab memory


.. _clearfun: clearfun.html
.. _intersci: intersci.html
.. _link: link.html
.. _newfun: newfun.html
.. _api_scilab: api_scilab.html


