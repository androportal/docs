

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Chapter 4 Operators &mdash; cpp 0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="cpp 0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">cpp 0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-4-operators">
<h1>Chapter 4 Operators<a class="headerlink" href="#chapter-4-operators" title="Permalink to this headline">¶</a></h1>
<p>C and C++ are languages that are rich in operators. The languages
provide arithmetic, relational, logical, bitwise, conditional and many
others.</p>
<div class="section" id="order-of-precedence-of-operators">
<h2>4.1 Order of Precedence of Operators<a class="headerlink" href="#order-of-precedence-of-operators" title="Permalink to this headline">¶</a></h2>
<p>Both <strong>C</strong> and <strong>C++</strong> have a great many operators. In fact one of the
criticisms of the <strong>C</strong> language is that it has too many operators
which makes the language difficult to read. The operators fall into
several categories: arithmetic, logical, relational, bitwise,
assignment and miscellaneous. Within a category the operators can be
classified into types: unary, binary, or ternary. The type indicates
the number of operands required with the operator. For instance, a
unary operator only requires a single operand, whereas a binary type
operator requires two operands, and of course ternary type operators
require three operands. The operators have an order of precedence
among themselves. This order of precedence dictates in what order the
operators are evaluated when several operators are together in a
statement or expression. Also, with each operator is an associativity
factor that tells in what order the operands associated with the
operator are to be evaluated. The following is a chart of the
operators in the <strong>C</strong> and <strong>C++</strong> language.</p>
<div class="section" id="table-4-1">
<h3>Table 4-1<a class="headerlink" href="#table-4-1" title="Permalink to this headline">¶</a></h3>
<p>Precedence and Associativity of Operators Operators Description
Associativity () function call left to right [] array element .
structure/union member -&gt; structure/union member using pointer !
logical not right to left ~ one&#8217;s complement - unary minus ++ &#8211;
increment/decrement &amp; address of * indirection (type) type cast sizeof
size in bytes * multiply left to right / divide % modulus + add left
to right - subtract &lt;&lt; left shift left to right &gt;&gt; right shift &lt; less
than left to right &lt;= less than or equal &gt; greater than &gt;= greater
than or equal == equal to left to right != not equal to &amp; bitwise AND
left to right ^ bitwise XOR left to right | bitwise OR left to right
&amp;&amp; logical AND left to right || logical OR left to right ?:
conditional right to left = assignment right to left <a href="#id1"><span class="problematic" id="id2">*</span></a>= multiply and
assign /= divide and assign %= modulo and assign += add and assign
/TR&gt; -= subtract and assign &lt;&lt;= left shift and assign &gt;&gt;= right shift
and assign &amp;= bitwise AND and assign ^= bitwise XOR and assign <a href="#id3"><span class="problematic" id="id4">|</span></a>=
bitwise OR and assign , comma left to right</p>
</div>
</div>
<div class="section" id="operators-arithmetic">
<h2>4.2 Operators: Arithmetic<a class="headerlink" href="#operators-arithmetic" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fig-4-1">
<h3>Fig 4-1<a class="headerlink" href="#fig-4-1" title="Permalink to this headline">¶</a></h3>
<p>Symbol Operator Example * multiplication a*b / division a/b % modulo
a%b + addition a+b - subtraction a-b</p>
<p>All arithmetic operators evaluate from left to right. When several
arithmetic operators, in fact operators of any type, appear within an
expression several passes of the expression may be necessary to
completely evaluate the expression.</p>
<p>Problems can occur if you mix <strong>unsigned</strong> variables with variables of
other data types. Due to differences in computer architecture,
unsigned variables do not always convert to the larger data type. This
can result in loss of accuracy, and even incorrect results. There are
other times when you might want to fully control the type conversions
instead of letting C and C++ make its best bet.</p>
<p>You can override C and C++&#8217;s default conversions by specifying your
own temporary type change. This process is called <strong>typecasting</strong>.
When you typecast, you temporarily change a variable&#8217;s data type from
its declared data type to a new one. The two formats of the typecast
are:</p>
<div class="highlight-python"><pre>   (data type) expression /* ANSI C method */

and

   data type(expression) // C++ method</pre>
</div>
<p>where <strong>data type</strong> can be any valid C and C++ data type, such as
<strong>int</strong> or <strong>float</strong>, and the <strong>expression</strong> can be a variable,
literal, or an expression that combines both. The following code
temporarily typecast the integer variable <strong>age</strong> into a double
floating-point variable, so that it can be multiplied by the double
floating-point <strong>factor</strong>. Both formats of the typecast are
illustrated.</p>
<div class="highlight-python"><pre>age_factor = (double)age * factor;</pre>
</div>
<p>The second way of typecasting puts the parentheses around the variable
rather than the data type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">age_factor</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</pre></div>
</div>
<p>Instead of having C and C++ perform the conversion, you might want to
typecast all mixed expression to ensure that they convert the way you
want them to.</p>
</div>
</div>
<div class="section" id="sizeof">
<h2>4.4 sizeof<a class="headerlink" href="#sizeof" title="Permalink to this headline">¶</a></h2>
<p>The <strong>sizeof</strong> operator returns the physical size, in bytes, of the
data item for which it is applied. It can be used with any type of
data item except bit fields. The general form is:</p>
<div class="highlight-python"><pre>size_t sizeof( item );</pre>
</div>
<p>When <strong>sizeof</strong> is used on a character field the result returned is 1
(if a character is stored in one byte). When used on an integer the
result returned is the size in bytes of that integer. When used on an
array the result is the number of bytes in the array, not the number
of characters which appear before a NULL. In the ANSI standard the
<strong>sizeof</strong> operator returns a data type of <strong>size_t</strong> which is usually
an <strong>unsigned int</strong> value.</p>
<div class="highlight-python"><pre>int nums[10];


printf("There are %d types in the array and %d elements"
, sizeof( nums ), sizeof( nums ) / sizeof( int ) );</pre>
</div>
</div>
<div class="section" id="relational-and-logical">
<h2>4.5 Relational and Logical<a class="headerlink" href="#relational-and-logical" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fig-4-2">
<h3>Fig 4-2<a class="headerlink" href="#fig-4-2" title="Permalink to this headline">¶</a></h3>
<p>Symbol Operator Example &lt; less than a &lt; B &gt; greater than a &gt; b &gt;=
greater than or equal a &gt;= b == equal to a==b != not equal a!=b
<strong>Logical:</strong></p>
</div>
<div class="section" id="fig-4-3">
<h3>Fig 4-3<a class="headerlink" href="#fig-4-3" title="Permalink to this headline">¶</a></h3>
<p>Sample Operator Example ! NOT !(a &lt; b) &lt; &gt;/TR&gt; &amp;&amp; AND a &lt; b &amp;&amp; c &gt; d
|| OR a || d
Relational and logical operators evaluate to only a true (1) or false
(0) value. Relational operators have a higher order of precedence that
logical operators and therefore are evaluated first in any expression
that includes both types of operators.</p>
</div>
</div>
<div class="section" id="the-conditional-operator">
<h2>4.6 The Conditional Operator<a class="headerlink" href="#the-conditional-operator" title="Permalink to this headline">¶</a></h2>
<p>The conditional operator is C and C++&#8217;s only ternary operator. It
works on three values as opposed to the binary operators you have seen
that operate on only two valurs. The conditional operator is used to
replace if-else logic in some situations. It is a two-symbol operator,
<strong>?:</strong>, with the following format:</p>
<div class="highlight-python"><pre>result = conditional_expression ? expression1 :expression2;</pre>
</div>
<p>The <strong>conditional_expression</strong> is any expression in C and C++ that
results in a True (nonzero) or False (zero) answer. If the result of
<strong>conditional_expression**is true, **expression1</strong> executes.
Otherwise, if the result of <strong>conditional_expression</strong> is false,
<strong>expression2</strong> executes. Only one of the expressions following the
question mark ever executes. Only a single semicolon appears at the
end of <strong>expression2</strong>. The internal expressions, such as
<strong>expression1</strong>, do not have a semicolon. The resultant value
generated by the expression that is executed is returned and can be
captured into the result identifier.</p>
<p>If you require simple if-else logic, the conditional operator usually
provides a more direct and succinct method, although you should always
prefer readability over compact code.</p>
<p>To glimpse the conditional operator at work, consider the section of
code that follows:</p>
<div class="highlight-python"><pre>if( a &gt; b )
   ans = 10;
else
   ans = 25;</pre>
</div>
<p>You can easily rewrite this kind of <strong>if-else</strong> code by using a single
conditional operator.</p>
<div class="highlight-python"><pre>ans = a &gt; b ? 10 : 25;</pre>
</div>
</div>
<div class="section" id="increment-and-decrement">
<h2>4.7 Increment and Decrement<a class="headerlink" href="#increment-and-decrement" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fig-4-4">
<h3>Fig 4-4<a class="headerlink" href="#fig-4-4" title="Permalink to this headline">¶</a></h3>
<p>Symbol Operator Example ++ increment a++ or ++a &#8211; decrement a&#8211; or
&#8211;a</p>
<p>The decrement and increment operators function the same whether the
operator is pre (meaning before the operand) or post (meaning after
the operand). When the operators are used in conjunction with a
conditional test, such as in an if statement or a loop control
conditional test, then the placement of the operator in relationship
to the operand is taken into account as to when to decrement or
increment the value of the operand.</p>
</div>
</div>
<div class="section" id="assignment">
<h2>4.8 Assignment<a class="headerlink" href="#assignment" title="Permalink to this headline">¶</a></h2>
<div class="section" id="fig-4-5">
<h3>Fig 4-5<a class="headerlink" href="#fig-4-5" title="Permalink to this headline">¶</a></h3>
<p>Symbol Operator Example = assignment a = b += addition and assignment
a += b same as a = a + b -= subtraction and assignment a -= b same as
a = a - b <a href="#id5"><span class="problematic" id="id6">*</span></a>= multiplication and assignment a <a href="#id7"><span class="problematic" id="id8">*</span></a>= b same as a = a * b /=
division and assignment a /= b same as a = a / b %= modulo and
assignment a %= b same as a = a % b &amp;= bitwise AND assignment a &amp;= b
same as a = a &amp; b <a href="#id9"><span class="problematic" id="id10">|</span></a>= bitwise OR and assignment a <a href="#id11"><span class="problematic" id="id12">|</span></a>= b same as a = a |
b ^= bitwise XOR and assignment a ^= b same as a = a ^ b &lt;&lt;= shift
left and and assignment a &lt;&lt;= 2 same as a = a &lt;&lt; 2 &gt;&gt;= shift right and
assignment a &gt;&gt;= 4 same as a = a &gt;&gt; 4</p>
<p>The various assignment operators are intended as a shorthand method.
Depending upon the machine architecture, the shorthand notation could
be faster than the traditional method.</p>
</div>
</div>
<div class="section" id="bitwise-operators">
<h2>4.9 Bitwise Operators<a class="headerlink" href="#bitwise-operators" title="Permalink to this headline">¶</a></h2>
<p>Each of the bitwise operators affects individual bits in a value. Some
of these operators are binary, taking two bits and returning a third
bit. Bitwise operators only work on values that reside in a word or
less of storage. Bitwise operators cannot be used with floating point,
double, or long values. The size of a word will vary from one machine
architecture to another.</p>
<p>The order of precedence for the bitwise operators is as follows:</p>
<div class="section" id="table-4-2">
<h3>Table 4-2<a class="headerlink" href="#table-4-2" title="Permalink to this headline">¶</a></h3>
<p>Bitwise Operators Operator Description Associativity ~ Ones complement
right to left &lt;&lt; Left shift left to right &gt;&gt; Right shift left to right
&amp; Bitwise AND left to right ^ Bitwise XOR left to right | Bitwise OR
left to right</p>
</div>
</div>
<div class="section" id="bitwise-complement">
<h2>4.10 Bitwise Complement: ~<a class="headerlink" href="#bitwise-complement" title="Permalink to this headline">¶</a></h2>
<p>This operator is a unary operator, that flips the value of each bit.
The operator takes a bit and converts it to 0 if the bit was 1 and to
1 if the bit was 0.</p>
<div class="section" id="table-4-3">
<h3>Table 4-3<a class="headerlink" href="#table-4-3" title="Permalink to this headline">¶</a></h3>
<p>Truth Table: Ones Complement (~) value ~value 0 1 1 0</p>
<p>Assuming 16 bit integers and that <strong>unsigned int Z</strong> is <strong>0xA</strong>, the
expression <strong>~Z</strong> has the value <strong>0xFFF5</strong> as shown below:</p>
</div>
<div class="section" id="table-4-4">
<h3>Table 4-4<a class="headerlink" href="#table-4-4" title="Permalink to this headline">¶</a></h3>
<p>Example Expression Binary Representation Value Z 0000 0000 0000 1010
0xA ~Z 1111 1111 1111 0101 0xFFF5</p>
<p>The bitwise complement operator should not be confused with the
arithmetic unary minus (-) or the logical negation (!). For example,
if <strong>Z</strong> is defined to be an int and set equal to <strong>0</strong>, then <strong>-Z</strong>
results in <strong>0</strong> and <strong>!Z</strong> is <strong>1</strong>, but <strong>~Z</strong> yields <strong>-1</strong> on a
2&#8217;s complement machine.</p>
<p>The bitwise complement operator is useful in writing portable code as
it avoids inclusion of machine-dependent information in the program.
For example, the statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Z</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0xFF</span><span class="p">;</span>
</pre></div>
</div>
<p>sets the last 8 bits of <strong>Z</strong> to <strong>0</strong>, independent of word length.</p>
</div>
</div>
<div class="section" id="bitwise-shift-operators">
<h2>4.11 Bitwise Shift Operators<a class="headerlink" href="#bitwise-shift-operators" title="Permalink to this headline">¶</a></h2>
<p>C provides two bitwise shift operators, bitwise left shift ( <strong>&lt;&lt;</strong>)
and bitwise right shift ( <strong>&gt;&gt;</strong>), for shifting bits left or right by
an integral number of positions in integral data. Both of these
operators are binary, and the left operand is the integral data whose
bits are to be shifted, and the right operand, called the shift count,
specifies the number of positions by which bits need shifting. The
shift count must be nonnegative and less than the number of bits
required to represent data of the type of the left operand.</p>
<p>Automatic unary conversions are performed on both operands. However,
the type of the result is that of the promoted left operand; the right
operand does not promte the result.
The result of applying these operators to signed operands is
implementation-dependent. For portability, therefore, these operators
should only be used on unsigned operands.</p>
<p>These operators can also be used, like other binary operators, to form
compound assignment operators <strong>&gt;&gt;=</strong> and <strong>&lt;&lt;=</strong>.</p>
</div>
<div class="section" id="left-shift-operator">
<h2>4.11.1 Left Shift Operator: &lt;&lt;<a class="headerlink" href="#left-shift-operator" title="Permalink to this headline">¶</a></h2>
<p>The left shift operator shifts bits to the left, and has the formation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">intvalue</span> <span class="o">&lt;&lt;</span> <span class="n">intvalue</span>
</pre></div>
</div>
<p>As bits are shifted toward high-order positions, <strong>0</strong> bits enter the
low-order positions. Bits shifted out through the high-order position
are lost. For example, given</p>
<div class="highlight-python"><pre>    unsigned int Z = 5;

and 16-bit integers, that is,

    Z is 00000000 00000101

then

    Z &lt;&lt; 1 is 00000000 00001010  or 10 decimal

and

    Z &lt;&lt; 15 is 10000000 00000000 or 32768 decimal</pre>
</div>
</div>
<div class="section" id="right-shift-operator">
<h2>4.11.2 Right Shift Operator: &gt;&gt;<a class="headerlink" href="#right-shift-operator" title="Permalink to this headline">¶</a></h2>
<p>The right shift operator shifts bits to the right, and has the
formation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">intvalue</span> <span class="o">&gt;&gt;</span> <span class="n">intvalue</span>
</pre></div>
</div>
<p>As bits are shifted toward low-order position, <strong>0</strong> bits enter the
high-order positions, if the data is unsigned. If the data is signed
and the sign bit is <strong>0</strong>, then <strong>0</strong> bits also enter the high- ordr
positions. However, if the sign bit is <strong>1</strong>, the bits entering high-
order positions are implementation-dependent. On some machines <a href="#id13"><span class="problematic" id="id14">**</span></a>1**s,
and on others <a href="#id15"><span class="problematic" id="id16">**</span></a>0**s, are shifted in. The former type of operation is
known as the arithmetic right shift, and the latter type the logical
right shift. For example, given</p>
<div class="highlight-python"><pre>    unsigned int Z = 40960;

and 16-bit integers, that is

    Z is 10100000 00000000

then

    Z &gt;&gt; 1 is 01010000 00000000 or 20480 decimal

and
    Z &gt;&gt; 15 is 00000000 00000001 or 1 decimal</pre>
</div>
<p>In the second example, the <strong>1</strong> originally in the fourteenth bit
position has dropped off. Another right shift will drop off the <strong>1</strong>
in the first bit position, and <strong>Z</strong> will become zero.</p>
</div>
<div class="section" id="multiplication-and-division-thru-shifting-bits">
<h2>4.12 Multiplication and Division thru Shifting Bits<a class="headerlink" href="#multiplication-and-division-thru-shifting-bits" title="Permalink to this headline">¶</a></h2>
<p>The left shift of a value by one position has the effect of
multiplying the value by two, unless an overflow occurs due to a <strong>1</strong>
falling off from the high-order position. Similarly, the right shift
of a value by one position has the effect of dividing the value by
two, provided the value is nonnegative. Here are some examples,
assuming 16-bit integers:</p>
<div class="section" id="table-4-5">
<h3>Table 4-5<a class="headerlink" href="#table-4-5" title="Permalink to this headline">¶</a></h3>
<p>Z as each statement executes unsigned int Z Binary Representation
Decimal Value Z=3 00000000 00000011 3 Z &lt;&lt; 1 00000000 00000110 6 Z &lt;&lt;
4 00000000 01100000 96 Z &lt;&lt; 9 11000000 00000000 49152 Z &lt;&lt; 1 10000000
00000000 32768 Z &gt;&gt; 1 01000000 00000000 16384 Z &gt;&gt; 9 00000000 00100000
32 Z &gt;&gt; 4 00000000 00000010 2 Z &gt;&gt; 1 00000000 00000001 1 Z &gt;&gt; 1
00000000 00000000 0
The operation <strong>Z &lt;&lt; 1</strong>, when the value of <strong>Z</strong> is <strong>49152</strong> results
in an overflow and does not have the effect of multiplication by
<strong>2</strong>. However, the operation <strong>Z &gt;&gt; 1</strong>, when the value of <strong>Z</strong> is
<strong>1</strong>, has the effect of integer division. Remember, shifting left is
a multiply by 2 at each bit position, where shifting right is dividing
by 2 at each bit position shifted.</p>
</div>
</div>
<div class="section" id="precedence-and-associativity">
<h2>4.13 Precedence and Associativity<a class="headerlink" href="#precedence-and-associativity" title="Permalink to this headline">¶</a></h2>
<p>Left and right shift operators have equal precedence and they
associate from left to right. Thus, the expression</p>
<div class="highlight-python"><pre>    1 &lt;&lt; 1 &gt;&gt; 2

is interpreted as

    (1 &lt;&lt; 1) &gt;&gt; 2</pre>
</div>
<p>The precedence of the shift operators is lower than that of any
arithmetic operator, but higher than that of any bitwise logical
operator except the unary bitwise complement operator. Thus, the
express</p>
<div class="highlight-python"><pre>    1 &lt;&lt; 2 - 1

is interpreted as

    1 &lt;&lt; (2 -1)

and the expression

    01 | ~01 &lt;&lt; 1

is interpreted as

    01 | ( ( ~01 ) &lt;&lt; 1 )</pre>
</div>
</div>
<div class="section" id="bitwise-and-operator">
<h2>4.14 Bitwise AND Operator: &amp;<a class="headerlink" href="#bitwise-and-operator" title="Permalink to this headline">¶</a></h2>
<p>This is not the address of operator, but the bitwise AND operator. The
address of operator is a unary operator that has only one operand,
whereas the bitwise AND operator is a binary operator and thus
requires two operands.
The bitwise AND operator <strong>&amp;</strong> has the formation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">intvalue</span> <span class="o">&amp;</span> <span class="n">intvalue</span>
</pre></div>
</div>
<p>When it is applied to two integral operands, the binary
representations of the converted values of the operands are compared
bit by bit. If <strong>Z1</strong> and <strong>Z2</strong> represent corresponding bits of the
two operands, then the result of <strong>Z1 &amp; Z2</strong> is shown in the following
truth table:</p>
<div class="section" id="table-4-6">
<h3>Table 4-6<a class="headerlink" href="#table-4-6" title="Permalink to this headline">¶</a></h3>
<p>Truth Table for Bitwise AND (&amp;) Z1 Z2 Z1 &amp; Z2 1 1 1 1 0 0 0 1 0 0 0 0</p>
<p>For example, given that</p>
<div class="highlight-python"><pre>unsigned int Z1 = 0xA, Z2 = 0x7;</pre>
</div>
<p>and that an integer is represented in 16 bits in the machine being
used, the expression <strong>Z1 &amp; Z2</strong> has the value <strong>0x2</strong> as show below:</p>
</div>
<div class="section" id="table-4-7">
<h3>&lt; Table 4-7<a class="headerlink" href="#table-4-7" title="Permalink to this headline">¶</a></h3>
<p>Expression Binary Representation Value Z1 0000 1010 0xA Z2 0000 0111
0x7 Z1 &amp; Z2 0000 0010 0x2</p>
<p>The logical AND operator <strong>&amp;&amp;</strong> and the bitwise AND operator <strong>&amp;</strong> are
quite different. The result of applying <strong>&amp;&amp;</strong> is always <strong>0</strong> or
<strong>1</strong>, but that of <strong>&amp;</strong> depends upon the values of the operands.
For example, whereas the value of the expresseion <strong>0xA &amp;&amp; 0x7</strong> is
<strong>1</strong>, the value of <strong>0xA &amp; 0x7</strong> is <strong>0x2</strong>. Only in the special case
when the values of the operands are restricted to be <strong>0</strong> or <strong>1</strong> is
the result of applying <strong>&amp;</strong> and <strong>&amp;&amp;</strong> the same. Moreover, in the
case of <strong>&amp;&amp;</strong>, the second operand is not evaluated if the first
operand is <strong>0</strong>, but both operands are evaluated in the case of
<strong>&amp;</strong>.</p>
<p>The bitwise AND operator is often used to turn some specified bits
off, that is, to set them to <strong>0</strong>. For example, the statement</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Z1</span> <span class="o">&amp;=</span> <span class="n">Z2</span><span class="p">;</span>
</pre></div>
</div>
<p>as shown in the preceding example, turns off all but the low- order
three bits of <strong>Z1</strong>. Those three bits remain unchanged.</p>
</div>
</div>
<div class="section" id="bitwise-inclusive-or-operator">
<h2>4.15 Bitwise Inclusive OR Operator: |<a class="headerlink" href="#bitwise-inclusive-or-operator" title="Permalink to this headline">¶</a></h2>
<p>The bitwise inclusive OR operator <strong>|</strong>, frequently referred to simply
as the bitwise OR operator, has the formation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">intvalue</span> <span class="o">|</span> <span class="n">intvalue</span>
</pre></div>
</div>
<p>As in the case of the bitwise AND operator, when the bitwise OR
operator is applied to two integral operands, the binary
representations of the converted values of the operands are compared
bit by bit. If <strong>Z1</strong> and <strong>Z2</strong> represent corresponding bits of the
two operands, then the result of <strong>Z1 | Z2</strong> is as shown in the
following truth table:</p>
<div class="section" id="table-4-8">
<h3>Table 4-8<a class="headerlink" href="#table-4-8" title="Permalink to this headline">¶</a></h3>
<p>Truth Table for Bitwise OR (|) Z1 Z2 Z1 | Z2 1 1 1 1 0 1 0 1 1 0 0 0</p>
<p>For example, given that</p>
<div class="highlight-python"><pre>unsigned int Z1 = 0xA, Z2 = 0x7;</pre>
</div>
<p>and that an integer is represented in 16 bits in the machine being
used, the expression <strong>Z1 | Z2</strong> has the value <strong>0xF</strong> as show below:</p>
</div>
<div class="section" id="table-4-9">
<h3>Table 4-9<a class="headerlink" href="#table-4-9" title="Permalink to this headline">¶</a></h3>
<p>Expression Binary Representation Value Z1 0000 1010 0xA Z2 0000 0111
0x7 Z1 | Z2 0000 1111 0xF</p>
<p>The logical OR operator <strong>||</strong> and the bitwise OR operator <strong>|</strong> are
also quite different. The result of applying <strong>|</strong> depends upon the
values of the operands, but that of <strong>||</strong> is always <strong>0</strong> or <strong>1</strong>.
Only in the special case when the values of the operands are
restricted to be <strong>0</strong> or <strong>1</strong> is the result of <strong>|</strong> and <strong>||</strong> the
same. Further, in the case of <strong>||</strong>, the second operand is not
evaluated if the first operand is <strong>1</strong>, but both operands are
evaluated in the case of <strong>|</strong>.</p>
<p>The bitwise OR operator is frequently used to turn some specified bits
on, that is, to set them to 1. For example, the statment</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Z1</span> <span class="o">|=</span> <span class="n">Z2</span><span class="p">;</span>
</pre></div>
</div>
<p>as shown in the preceding example, ensures that the three rightmost
bits of <strong>Z1</strong> are turned on.</p>
</div>
</div>
<div class="section" id="bitwise-exclusive-or-operator">
<h2>4.16 Bitwise Exclusive OR Operator: ^<a class="headerlink" href="#bitwise-exclusive-or-operator" title="Permalink to this headline">¶</a></h2>
<p>The bitwise exclusive OR operator <strong>^</strong>, frequently referred to as the
bitwise XOR operator, has the formation</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">intvalue</span> <span class="o">^</span> <span class="n">intvalue</span>
</pre></div>
</div>
<p>In the case of the bitwise exclusive OR also, the binary
representations of the converted values of the operands are compared
bit by bit. If <strong>Z1</strong> and <strong>Z2</strong> represent corresponding bits of the
two operands, then the result of <strong>Z1 ^ Z2</strong> is as shown in the
following truth table:</p>
<div class="section" id="table-4-10">
<h3>Table 4-10<a class="headerlink" href="#table-4-10" title="Permalink to this headline">¶</a></h3>
<p>Truth Table for Bitwise XOR (^) Z1 Z2 Z1 ^ Z2 1 1 0 1 0 1 0 1 1 0 0 0</p>
<p>For example, given that</p>
<div class="highlight-python"><pre>unsigned int Z1 = 0xA, Z2 = 0x7;</pre>
</div>
<p>and that an integer is represented in 16 bits in the machine being
used, the expression <strong>Z1 ^ Z2</strong> has the value <strong>0x9</strong> as show below:</p>
</div>
<div class="section" id="table-4-11">
<h3>Table 4-11<a class="headerlink" href="#table-4-11" title="Permalink to this headline">¶</a></h3>
<p>Expression Binary Representation Value Z1 0000 1010 0xA Z2 0000 0111
0x7 Z1 ^ Z2 0000 1001 0x9
The exclusive OR operator has the property that any value XORed with
itself produces <strong>0</strong>. as the result. Thus, we have</p>
</div>
<div class="section" id="table-4-12">
<h3>Table 4-12<a class="headerlink" href="#table-4-12" title="Permalink to this headline">¶</a></h3>
<p>Expression Binary Representation Value Z1 0000 1010 0xA Z1 0000 1010
0xA Z1 ^ Z1 0000 0000 0x0</p>
<p>This property is often used by assembly language programmers to set a
value to <strong>0</strong> or to compare two values to determine if they are
equal.</p>
<p>Another useful property of this operator is that if the result of
XORing a value with another value is again XORed with the second
value, the result is the first value. Thus we have</p>
</div>
<div class="section" id="table-4-13">
<h3>Table 4-13<a class="headerlink" href="#table-4-13" title="Permalink to this headline">¶</a></h3>
<p>Expression Binary Representation Value Z1 0000 1010 0xA Z2 0000 0111
0x7 Z1 ^ Z1 0000 0000 0x0 Z1 ^ Z2 0000 1101 0xD (Z1 ^ Z2) ^ Z2 0000
1010 0xA</p>
<p>That is, <strong>(Z1 ^ Z2) ^ Z2</strong> is equal to <strong>Z1</strong>. This property is
frequently used in designing bit-manipulation ciphers in cryptography.</p>
<p>The bitwise exclusive OR operator can also be used to interchange two
values without using a temporary variable. Thus, the statement</p>
<div class="highlight-python"><pre>Z1 ^= Z2, Z2 ^= Z1, Z1 ^= Z2;</pre>
</div>
<p>swaps the values of <strong>Z1</strong> and <strong>Z2</strong>, as shown below:</p>
</div>
<div class="section" id="table-4-14">
<h3>Table 4-14<a class="headerlink" href="#table-4-14" title="Permalink to this headline">¶</a></h3>
<p>Expression Binary Representation Value Z1 0000 1010 0xA Z2 0000 0111
0x7 Z1 ^= Z2 0000 1010 0xD Z2 ^= Z1 0000 1101 0xA Z1 ^= Z2 0000 0111
0x7</p>
</div>
</div>
<div class="section" id="id17">
<h2>4.17 Precedence and Associativity<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>The order of precedence of the bitwise logical operators is bitwise
complement, bitwise AND, bitwise exclusive OR, and then bitwise
inclusive OR. Except for the bitwise complement that associates from
right to left, all others associate from left to right. Thus, the
expression</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mo">01</span> <span class="o">|</span> <span class="o">~</span><span class="mo">01</span> <span class="o">^</span> <span class="mo">01</span> <span class="o">&amp;</span> <span class="mo">01</span>
</pre></div>
</div>
<p>is interpreted as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mo">01</span> <span class="o">|</span> <span class="p">(</span> <span class="p">(</span> <span class="o">~</span><span class="mo">01</span> <span class="p">)</span> <span class="o">^</span> <span class="p">(</span> <span class="mo">01</span> <span class="o">&amp;</span> <span class="mo">01</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Note that the precedence of the binary bitwise logical operators is
lower than the equality operator <strong>==</strong> and the inequality operator
<strong>!=</strong>. Thus, parentheses are necessary in expressions such as</p>
<div class="highlight-python"><pre>    ( i &amp; 01 ) == 0

or

    ( i ^ 01 ) != 0</pre>
</div>
</div>
<div class="section" id="sequence-points-or-comma">
<h2>4.18 Sequence Points or comma<a class="headerlink" href="#sequence-points-or-comma" title="Permalink to this headline">¶</a></h2>
<p>The comma operator is used to insure that parts of an expression are
performed in a left to right sequence. The comma allows for the use of
multiple expressions to be used where normally only one would be
allowed. It is used most often in the <strong>for</strong> loop statement where one
statement is called for, but several actually need to be coded.</p>
<p>The comma operator forces all operations that appear to the left to be
fully completed before proceeding to the right of comma. This helps
eliminate side effects of the expression evaluation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">num1</span> <span class="o">=</span> <span class="n">num2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>The comma insures that <strong>num2</strong> will not be changed to a 2 before
<strong>num2</strong> has been added to 1 and the result placed into <strong>num1</strong>.</p>
<p>Other operators are also considered to be sequence points. They are:</p>
<div class="highlight-python"><pre>&amp;&amp;
||
?:</pre>
</div>
<p>When any of these operators are encountered all activity associated
with any operator to the left is completed before the new operator
begins executing. Both the semicolon and the comma also perform this
service, insuring that there is a way to control the order of when
things happen in a program.</p>
<p>The commas that separate the actual arguments in a function call are
punctuation symbols, not sequence points. A punctuation symbol does
not guarantee that the arguments are either evaluated or passed to the
function in any particular order.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Chapter 4 Operators</a><ul>
<li><a class="reference internal" href="#order-of-precedence-of-operators">4.1 Order of Precedence of Operators</a><ul>
<li><a class="reference internal" href="#table-4-1">Table 4-1</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operators-arithmetic">4.2 Operators: Arithmetic</a><ul>
<li><a class="reference internal" href="#fig-4-1">Fig 4-1</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sizeof">4.4 sizeof</a></li>
<li><a class="reference internal" href="#relational-and-logical">4.5 Relational and Logical</a><ul>
<li><a class="reference internal" href="#fig-4-2">Fig 4-2</a></li>
<li><a class="reference internal" href="#fig-4-3">Fig 4-3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-conditional-operator">4.6 The Conditional Operator</a></li>
<li><a class="reference internal" href="#increment-and-decrement">4.7 Increment and Decrement</a><ul>
<li><a class="reference internal" href="#fig-4-4">Fig 4-4</a></li>
</ul>
</li>
<li><a class="reference internal" href="#assignment">4.8 Assignment</a><ul>
<li><a class="reference internal" href="#fig-4-5">Fig 4-5</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitwise-operators">4.9 Bitwise Operators</a><ul>
<li><a class="reference internal" href="#table-4-2">Table 4-2</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitwise-complement">4.10 Bitwise Complement: ~</a><ul>
<li><a class="reference internal" href="#table-4-3">Table 4-3</a></li>
<li><a class="reference internal" href="#table-4-4">Table 4-4</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitwise-shift-operators">4.11 Bitwise Shift Operators</a></li>
<li><a class="reference internal" href="#left-shift-operator">4.11.1 Left Shift Operator: &lt;&lt;</a></li>
<li><a class="reference internal" href="#right-shift-operator">4.11.2 Right Shift Operator: &gt;&gt;</a></li>
<li><a class="reference internal" href="#multiplication-and-division-thru-shifting-bits">4.12 Multiplication and Division thru Shifting Bits</a><ul>
<li><a class="reference internal" href="#table-4-5">Table 4-5</a></li>
</ul>
</li>
<li><a class="reference internal" href="#precedence-and-associativity">4.13 Precedence and Associativity</a></li>
<li><a class="reference internal" href="#bitwise-and-operator">4.14 Bitwise AND Operator: &amp;</a><ul>
<li><a class="reference internal" href="#table-4-6">Table 4-6</a></li>
<li><a class="reference internal" href="#table-4-7">&lt; Table 4-7</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitwise-inclusive-or-operator">4.15 Bitwise Inclusive OR Operator: |</a><ul>
<li><a class="reference internal" href="#table-4-8">Table 4-8</a></li>
<li><a class="reference internal" href="#table-4-9">Table 4-9</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitwise-exclusive-or-operator">4.16 Bitwise Exclusive OR Operator: ^</a><ul>
<li><a class="reference internal" href="#table-4-10">Table 4-10</a></li>
<li><a class="reference internal" href="#table-4-11">Table 4-11</a></li>
<li><a class="reference internal" href="#table-4-12">Table 4-12</a></li>
<li><a class="reference internal" href="#table-4-13">Table 4-13</a></li>
<li><a class="reference internal" href="#table-4-14">Table 4-14</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">4.17 Precedence and Associativity</a></li>
<li><a class="reference internal" href="#sequence-points-or-comma">4.18 Sequence Points or comma</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chap04.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">cpp 0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, demo.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>